--实现包中定义的函数
CREATE OR REPLACE BODY ASSET_CHANGE AS
	FUNCTION GET_BALANCE (SERIALNUMBERS VARCHAR2,ASSETYPES VARCHAR2,STARTCOUPONDATE VARCHAR2, ENDDAYCURRENT VARCHAR,BUZTYPE VARCHAR2,CUSNUMBER VARCHAR2)
		RETURN DATA_TABLE --返回表类型
		PIPELINED
	DECLARE
		v_list VARCHAR2(4000);
		v_list1 VARCHAR2(4000);
		l_idx PLS_INTEGER;
		l_idx1 PLS_INTEGER;
		l_idx2 PLS_INTEGER;
		p_sep VARCHAR2(1) := ',';
		assetype VARCHAR2(200);
		serialnum varchar2(200);
		TYPE STR_A IS VARRAY(14) OF VARCHAR2(15);
		assetype_a STR_A := STR_A('','','','','','','','','','','','','','');
		TYPE BCT  IS REF CURSOR;
		v_bc BCT;
		v_stmt_str VARCHAR2(200);
		B_RECORD DATA_RECORD;
	BEGIN
		v_list := ASSETYPES;
		v_list1 := SERIALNUMBERS;
		l_idx2 := 0;
		LOOP
			l_idx2 := l_idx2 + 1;
			l_idx := "INSTR"(v_list, p_sep);
					IF l_idx >0 THEN 
						assetype := "SUBSTR"(v_list, 1, l_idx-1);
						v_list := "SUBSTR"(v_list, l_idx+"LENGTH"(p_sep));
						assetype_a(l_idx2):= assetype;
					ELSE
						assetype:= v_list;
						assetype_a(l_idx2):= assetype;
						EXIT;
					END IF;
		END LOOP;
		LOOP 
				l_idx1:= "INSTR"(v_list1, p_sep);
				IF l_idx1 >0 THEN
					serialnum := "SUBSTR"(v_list1, 1, l_idx1-1);
					v_list1 := "SUBSTR"(v_list1, l_idx1+"LENGTH"(p_sep));
					IF ASSETYPES IS NULL THEN
						l_idx2 := 1;
						v_stmt_str := 'select DISTINCT ASSETTYPE from BALANCE where KEEPFOLDER_ID = :j';
						OPEN v_bc FOR v_stmt_str USING serialnum;
							LOOP
								FETCH v_bc INTO assetype_a(l_idx2);
								EXIT WHEN v_bc%NOTFOUND;
								l_idx2 := l_idx2+1;	
							END LOOP;
						CLOSE v_bc;
						l_idx2 := l_idx2-1;
					END IF;
					FOR i in 1..l_idx2 LOOP
						B_RECORD := GET_ALMOST_BALANCE (serialnum ,ASSETYPE ,STARTCOUPONDATE , ENDDAYCURRENT ,BUZTYPE ,CUSNUMBER);
						PIPE ROW(B_RECORD);
					END LOOP;
				ELSE
					serialnum:= v_list1;
					IF ASSETYPES IS NULL THEN
						l_idx2 := 1;
						v_stmt_str := 'select DISTINCT ASSETTYPE from BALANCE where KEEPFOLDER_ID = :j';
						OPEN v_bc FOR v_stmt_str USING serialnum;
							LOOP
								FETCH v_bc INTO assetype_a(l_idx2);
								EXIT WHEN v_bc%NOTFOUND;
								l_idx2 := l_idx2+1;	
							END LOOP;
						CLOSE v_bc;
						l_idx2 := l_idx2-1;
					END IF;
					FOR i in 1..l_idx2 LOOP
						B_RECORD := GET_ALMOST_BALANCE (serialnum ,ASSETYPE ,STARTCOUPONDATE , ENDDAYCURRENT ,BUZTYPE ,CUSNUMBER);
						PIPE ROW(B_RECORD);
					END LOOP;
					EXIT;
				END IF;
		END LOOP;
	END GET_BALANCE;
	FUNCTION GET_ALMOST_BALANCE (SERIALNUMBER VARCHAR2,ASSETYPE VARCHAR2,STARTCOUPONDATE VARCHAR2, ENDDAYCURRENT VARCHAR,BUZTYPE VARCHAR2,CUSNUMBER VARCHAR2)
		RETURN DATA_RECORD
	IS
		CONDITIONS VARCHAR2(4000);
		CONDITIONS_ONE VARCHAR2(4000);
		CONDITIONS_TWO VARCHAR2(4000);
		SQL_T VARCHAR2(10000);
		SQL_NL VARCHAR2(40) := 'NVL((SELECT A.';
		SQL_FR VARCHAR2(40) := ' FROM (SELECT SETTLEDATE,';
		SQL_GB VARCHAR2(40) := ' GROUP BY SETTLEDATE,';
		SQL_OB VARCHAR2(40) := ' ORDER BY SETTLEDATE DESC,';
		SQL_AW VARCHAR2(40) := ' DESC) A WHERE ROWNUM = 1),0)';
		type S_ARRAY is varray(10) of varchar2(20);
		FIELDS S_ARRAY;
		FIELDS_2 S_ARRAY;
		B_RECORD DATA_RECORD;
	BEGIN
		CONDITIONS := 'FROM BALANCE WHERE CUSNUMBER = ' || CUSNUMBER; --拼接条件
		CONDITIONS := CONDITIONS || ' AND SERIALNUMBER = ' || SERIALNUMBER || ' AND ASSETYPE = ' || ASSETYPE;
		IF BUZTYPE IS NOT NULL THEN
		  CONDITIONS := CONDITIONS || ' AND BUZTYPE = ' || BUZTYPE;
		END IF
		CONDITIONS_ONE := CONDITIONS|| 'AND SETTLEDATE >= ' || STARTCOUPONDATE 'AND SETTLEDATE <= ' || ENDDAYCURRENT; --日期条件1
		CONDITIONS_TWO := CONDITIONS|| 'AND SETTLEDATE <  ' || STARTCOUPONDATE;	--日期条件2
		--语句拼接
		FIELDS := S_ARRAY('INTERESTEARNING','RESERVEVALUE7','AMORTIZEEARNING','PRICEEARNING','FAIRVALUEINCOME','IMPAIRMENTLOST','RESERVEVALUE5','RESERVEVALUE6');
		FIELDS_2 := S_ARRAY('HOLDPOSITION','HOLDFACEAMOUNT','INTERESTADJUST','INTERESTCOST','FAIRVALUEALTER','IMPAIRMENT','CLEANPRICECOST','DIRTYPRICECOST');
		SQL_T := 'SELECT ';
		FOR i IN FIELDS.first..FIELDS.last LOOP
			SQL_T:= SQL_T || SQL_NL || FIELDS(i) || SQL_FR || FIELDS(i) || CONDITIONS_ONE
								|| SQL_GB || FIELDS(i) || SQL_OB || ' - ';
			SQL_T:=	SQL_T || SQL_NL || FIELDS(i) || SQL_FR || FIELDS(i) || CONDITIONS_TWO
								|| SQL_GB || FIELDS(i) || SQL_OB || 'AS ' || FIELDS(i) || ', ';
		END LOOP;
		FOR i IN FIELDS_2.first..FIELDS_2.last LOOP
			SQL_T:=	SQL_T || SQL_NL || FIELDS_2(i) || SQL_FR || FIELDS_2(i) || CONDITIONS_ONE
								|| SQL_GB || FIELDS_2(i) || SQL_OB || 'AS ' || FIELDS_2(i);
			IF i < FIELDS.last THEN 
					SQL_T := SQL_T || ', ';
			END IF;
		END LOOP;
		SQL_T := SQL_T || ' FROM DUAL';
		--执行语句
		EXECUTE IMMEDIATE SQL_T INTO 
			B_RECORD.INTERESTEARNING,B_RECORD.RESERVEVALUE7,B_RECORD.AMORTIZEEARNING,B_RECORD.PRICEEARNING,B_RECORD.FAIRVALUEINCOME
			,B_RECORD.IMPAIRMENTLOST,B_RECORD.RESERVEVALUE5,B_RECORD.RESERVEVALUE6,B_RECORD.HOLDPOSITION,B_RECORD.HOLDFACEAMOUNT
			,B_RECORD.INTERESTADJUST,B_RECORD.INTERESTCOST,B_RECORD.FAIRVALUEALTER,B_RECORD.IMPAIRMENT,B_RECORD.CLEANPRICECOST,B_RECORD.DIRTYPRICECOST;
		RETURN B_RECORD;
	END GET_ALMOST_BALANCE;
END ASSET_CHANGE;